NPM = Node Package Manager : Programmation modulaire, possibilité de récupérer des packages d'autres personnes.

Json = Fichier clé/valeur => "blabla" : "blublu" /OU\ "blabla" : { "blibli" : "blublu", "bloblo" : "bleble" }

Quand on installe avec bower, l'option -S permet de mettre les dépendances dans bower.json et figer la version : -E. -D => DevDependencies au lieu de Dependencies.
Possibilité de trouver la doc officielle sur doc.npmjs.com et Bower : bower.io/docs/api/install

jshintrc => Hinter, comme Sonar
jscsrc 	 => Format Styler

Toujours appeler le tag <script> juste avant la balise fermante </body>.
=> Vieux navigateurs, et permet d'afficher la page avant de s'occuper du js.
IE8 => Angular 1.2 + Script en fin de body.

IIFE : Immediatly Invoked Function Expression. Lancer une fonction dès qu'elle est finie de déclarer.
Tout mettre dans une fct permet de ne pas avoir de variable globale et de conflits.
Permet d'isoler les parties de codes entre elles.

On peut passer des instruction à jshint par le biais d'un commentaire de la forme : /* jshint -W003, -W038 */. Par exemple, ici, on demande à JSHint de ne pas afficher les warnings 003 et 038.
'use strict'; => Mode strict interdisant certaines construction (ex : on ne peut pas utiliser une variable que l'on a pas déclarer).
Spécifications officiels js : ECMA script.

Javascript : Une ligne ne peut pas mettre plus d'un certain temps à s'éxecuter (asynchrone).
Pas de threads. (Apache décline en prod' car multithread). Remplacé par : jenkins, divise les coûts de production par 10.
BOM = Brower object model. Console est un BOM. Taper this dans console de dév donne les commandes possibles. This est un BOM.

=== => Egale en type et en valeur. == => Egale en valeur.

Pour avoir une variable globale : window.variable = blabla.
Méthode avec this dedans => Constructeur.

var Animal = function() {									####	Permet de déclarer une classe, mettre des majuscules aux classes.
		this.eat = function() {								####	Permet d'ajouter une méthode à la classe.
			console.log('miam miam slurp slurp...');		####	
		};													####
	};														####
	
Chaque objet/classe a un prototype. Prototype = Objet, on peut lui ajouter des propriétés : Animal.prototype.sleep = function(){console.log('Zzzz...');
Proto = Une seule fonction mais les objets peuvent pointer dessus.
2 façons de construire des objets en JS:
	- var objet = {	a:1,	b:2,	c:"lolilol, prototype:{...} };
	- Définir un type (Animal) puis créer un objet de ce type.
	
Tous les objets ont une propriété cachée. (prototype)
On peut mettre des attributs dans le prototype.

Cat.prototype = new Animal(); => Equivalent de l'héritage.

var garfield = new Cat();
	garfield.speak();
	garfield.sleep();
	garfield.eat();
	
speak = fonction de Cat.
sleep = fonction dans le prototype.
eat   = fonction de Animal.



Hoisting = Soulever un objet. Le levage.
Pour faire une array : var tableau = []; OU var tableau2 = new Array();
Un array a forcément un prototype de type Array

Fonction passée en argument = callback.

app.use = Middleware.

var app = angular.module('myApp', []); le []permet de créer le module. Si on l'enlève, on ne fait que appeler le module.

On charge auto, puis "myApp" puis le module (Exemple 04).
Transclude affiche le contenu de ce que contenait la directive.

3 manières d'appeler une directive 
Façon attribut
Façon élément
Façon classe

A la fin d'un index.html il va dans angular.init et il compile.

Pour éviter un fouc : 
	- Mettre le script en haut puis rajouter ng-cloak dans le body
	OU
	- Garder le script en bas et rajouter un ficheir css contenant les ng-cloak (angular-csp.css de bower_components/angular/)
	
Après la compilation, angular enlève les ng-cloak qu'il a trouvé dans le code.

Fonction injectale : Fonction qui est déclarée dans un tableau

Variable en $$ = Variable angular, ne pas toucher.

Pour les form, setPristine => Remet form à l'état d'origine
Dès qu'on créé un controleur, on crée un scope avec lui.
Le rootscope est crée lors du ng-app.

Pour "brancher" un module : <script target="app" src="ors-star/ors-star.js"></script>
link: permet de lier une fonction à une directive.
Penser à ajouter les modules dans app.js dans la var app. Sinon, la fonction n'est pas executée.
Le nom du module doit être le même dans le fichier.js du module et dans le app.js

Fonction injectable = Tableau.

Créer un scope dans la directive (scope isolé) permet d'accéder facilement aux variables et de ne pas pourrir le rootScope

They watch me wip, they watch me nae nae, they watch me wip, wip, watch me nae nae!
Ouh! Watch me, watch me! Ouh! Watch me, watch me! Ouh! Watch me, watch me. Ouh! Ouh! Ouh! Ouh!

Lorsque code html, il faut compiler le code avec $compile s'il utilise ng-blabla.

Closure = Fonction qui fait appel à une ressource qui n'est pas un paramètre de la fonction. (Objet global par ex).
En JS pas de différence entre entier et décimal.
REST > SOAP
Angular 1.2 => IE8, sinon supérieur.
Service = $injectable
Si on crée un service, pas le droit de mettre $.
Variable touchée = Dirty
Variable non touchée = pristine.
Une variable qui passe en dirty est propagée => Dirty Checking.

Service = Association clé/valeur.
window = navigateur, $window = navigateur + node.

/!\ Un fichier par module /!\
On peut mettre autant de méthode/attribut que souhaité dans un service.
Il est possible d'avoir plusieurs app.config/app.run... etc
Config est prioritaire sur Run.
SPA = Single page application
Un service correspond toujours à un provider.
Provider = nomServiceProvider.

Je suis passe-partout, du fort Boyard!

3 recettes pour construire un service :
	- Recette value
	- Recette factory => Avantage sur value : Injection
	- Recette provider
	- Recette constante
	- Recette service
	
JavaScript typé fort = TypeScript

Fonction de hachage :
Anti-colisible
Homogène


Test Unitaire : module par module.
Pour utiliser un jeu de données => Fixture.

Pour les tests : autohotkey